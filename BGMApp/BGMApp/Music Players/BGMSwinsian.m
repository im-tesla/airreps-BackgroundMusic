// This file is part of Background Music.
//
// Background Music is free software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation, either version 2 of the
// License, or (at your option) any later version.
//
// Background Music is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Background Music. If not, see <http://www.gnu.org/licenses/>.

//
//  BGMSwinsian.m
//  BGMApp
//
//  Copyright Â© 2018 Kyle Neideck
//

// Self Include
#import "BGMSwinsian.h"

// Auto-generated Scripting Bridge header
#import "Swinsian.h"

// Local Includes
#import "BGMScriptingBridge.h"

// PublicUtility Includes
#import "CADebugMacros.h"


#pragma clang assume_nonnull begin

@implementation BGMSwinsian {
    BGMScriptingBridge* scriptingBridge;
}

- (instancetype) init {
    // If you're copying this class, replace the ID string with a new one generated by uuidgen (the
    // command line tool).
    NSUUID* musicPlayerID = [BGMMusicPlayerBase makeID:@"B74D18F6-DFF7-4D88-B719-429CFF98CFFA"];

    if ((self = [super initWithMusicPlayerID:musicPlayerID
                                        name:@"Swinsian"
                                    bundleID:@"com.swinsian.Swinsian"])) {
        scriptingBridge = [[BGMScriptingBridge alloc] initWithMusicPlayer:self];
    }
    
    return self;
}

- (SwinsianApplication* __nullable) swinsian {
    return (SwinsianApplication* __nullable)scriptingBridge.application;
}

- (void) wasSelected {
    [super wasSelected];
    [scriptingBridge ensurePermission];
}

- (BOOL) isRunning {
    // Note that this will return NO if is self.swinsian is nil (i.e. Swinsian isn't running).
    return self.swinsian.running;
}

// isPlaying and isPaused check self.running first just in case Swinsian is closed but self.swinsian
// hasn't become nil yet. In that case, reading self.swinsian.playerState could make Scripting
// Bridge open Swinsian.

- (BOOL) isPlaying {
    return self.running && (self.swinsian.playerState == SwinsianPlayerStatePlaying);
}

- (BOOL) isPaused {
    return self.running && (self.swinsian.playerState == SwinsianPlayerStatePaused);
}

- (BOOL) pause {
    // isPlaying checks isRunning, so we don't need to check it here and waste an Apple event.
    BOOL wasPlaying = self.playing;
    
    if (wasPlaying) {
        DebugMsg("BGMSwinsian::pause: Pausing Swinsian");
        [self.swinsian pause];
    }
    
    return wasPlaying;
}

- (BOOL) unpause {
    // isPaused checks isRunning, so we don't need to check it here and waste an Apple event.
    BOOL wasPaused = self.paused;
    
    if (wasPaused) {
        DebugMsg("BGMSwinsian::unpause: Unpausing Swinsian");
        [self.swinsian play];
    }
    
    return wasPaused;
}

@end

#pragma clang assume_nonnull end

